#pragma once//Create by steve in 16-9-12 at 下午2:04//// Created by steve on 16-9-12.//#include <ros/ros.h>#include <iostream>#include <deque>#include <sensor_msgs/Imu.h>//Multi-thread in c++11.#include <thread>#include <mutex>#include "Eigen/Dense"#ifndef IMU_NAVIGATION_DATASYNCHRONIZATION_H#define IMU_NAVIGATION_DATASYNCHRONIZATION_Hclass DataSync{public:    DataSync(ros::NodeHandle &n_h):            n_ptr_(&n_h),            x_h_(18)    {        //x_h_[1]  =1;        std::cout << x_h_ << std::endl;        imu1_sub_ = n_ptr_->advertise<sensor_msgs::Imu>("imu1/data",1,ImuCallBack);        imu2_sub_ = n_ptr_->advertise<sensor_msgs::Imu>("imu2/data",1,ImuCallBack);    }    ~DataSync()    {    }protected:    ros::NodeHandlePtr n_ptr_;//Pointer of the node.    ros::Subscriber imu1_sub_,imu2_sub_;//Subscriber for imu data.    std::deque<sensor_msgs::Imu> deque_imu1_;//Save data in a deque.    std::deque<sensor_msgs::Imu> deque_imu2_;    std::mutex deque_imu1_mutex_;    std::mutex deque_imu2_mutex_;    //Callback function,use for push imu msg to deque.    void ImuCallBack(const sensor_msgs::ImuConstPtr &imu_ptr);    Eigen::VectorXd x_h_;private:};void DataSync::ImuCallBack(const sensor_msgs::ImuConstPtr &imu_ptr) {    sensor_msgs::Imu tmp(*imu_ptr);    if(tmp.header.frame_id == "imu1")    {        deque_imu1_mutex_.lock();        deque_imu1_.push_back(tmp);        deque_imu1_mutex_.unlock();    }else{        deque_imu2_mutex_.lock();        deque_imu2_.push_back(tmp);        deque_imu2_mutex_.unlock();    }}#endif //IMU_NAVIGATION_DATASYNCHRONIZATION_H