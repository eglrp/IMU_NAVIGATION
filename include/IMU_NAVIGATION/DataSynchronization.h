#pragma once//Create by steve in 16-9-12 at 下午2:04//// Created by steve on 16-9-12.//#include <ros/ros.h>#include <iostream>#include <deque>#include <sensor_msgs/Imu.h>//Multi-thread in c++11.#include <thread>#include <mutex>#include "Eigen/Dense"#ifndef IMU_NAVIGATION_DATASYNCHRONIZATION_H#define IMU_NAVIGATION_DATASYNCHRONIZATION_Hclass DataSync{public:    DataSync(ros::NodeHandle &n_h):            n_ptr_(&n_h),            x_h_(18)    {        //x_h_[1]  =1;        std::cout << x_h_ << std::endl;        imu1_sub_ = n_ptr_->subscribe("imu1/data",1,&DataSync::ImuCallBack,this);        imu2_sub_ = n_ptr_->subscribe("imu2/data",1,&DataSync::ImuCallBack,this);        //std::cout << pow(3,3) << std::endl;    }    ~DataSync()    {    }    //Callback function,use for push imu msg to deque.    void ImuCallBack(const sensor_msgs::ImuConstPtr &imu_ptr);    //Get pair of imu data according to the time stamp.    Eigen::MatrixXd GetImuData(double time);    //Get imu data at the time stamp    Eigen::MatrixXd GetImuDataSingle(double time,std::deque<sensor_msgs> deque_imu);protected:    ros::NodeHandlePtr n_ptr_;//Pointer of the node.    ros::Subscriber imu1_sub_,imu2_sub_;//Subscriber for imu data.    std::deque<sensor_msgs::Imu> deque_imu1_;//Save data in a deque.    std::deque<sensor_msgs::Imu> deque_imu2_;    std::mutex deque_imu1_mutex_;    std::mutex deque_imu2_mutex_;    Eigen::VectorXd x_h_;    int queue_size_ = 20;private:};void DataSync::ImuCallBack(const sensor_msgs::ImuConstPtr &imu_ptr) {    sensor_msgs::Imu tmp(*imu_ptr);    if(tmp.header.frame_id == "imu1")    {        deque_imu1_mutex_.lock();        deque_imu1_.push_back(tmp);        deque_imu1_mutex_.unlock();    }else{        deque_imu2_mutex_.lock();        deque_imu2_.push_back(tmp);        deque_imu2_mutex_.unlock();    }}Eigen::MatrixXd DataSync::GetImuData(double time) {    Eigen::MatrixXd data(12,1);    Eigen::MatrixXd tmp_data(6,1);    /*     *     */    deque_imu1_mutex_.lock();    tmp_data = GetImuDataSingle(time,deque_imu1_);    while(deque_imu1_.size()>queue_size_)    {        deque_imu1_.pop_front();    }    deque_imu1_mutex_.unlock();    for(int i(0);i<6;++i)    {        data[i,1] = tmp_data[i,1];    }    ////////////////////////////////////////    deque_imu2_mutex_.lock();    tmp_data = GetImuDataSingle(time,deque_imu2_);    while(deque_imu2_.size() > queue_size_)    {        deque_imu2_.pop_front();    }    deque_imu2_mutex_.unlock();    for(int i(0);i<6;++i)    {        data[i+6,1] = tmp_data[i,1];    }    /*     *     */    return data;}Eigen::MatrixXd DataSync::GetImuDataSingle(double time,                                           std::deque<sensor_msgs> deque_imu) {    //Define the MatrixXd    //ToDo:Add code here.}#endif //IMU_NAVIGATION_DATASYNCHRONIZATION_H